# Migrating from Go PubSub v1 to v2

This page summarizes the changes needed to migrate from `cloud.google.com/go` (aka "the v1 library") to `cloud.google.com/go/pubsub/v2` (aka "the v2 library"). In line with Google's [OSS Library Breaking Change Policy](https://opensource.google/documentation/policies/library-breaking-change), we plan to support the existing v1 package for 12 months, until **June 31st, 2026**. This includes a commitment to bug and security patches for the v1 library, but it will not receive new features. We encourage all users to migrate to the new v2 library by the above date.

Note that this is a major version bump that includes breaking changes for the Go library specifically, but the Pub/Sub API (as defined by the [proto file](https://github.com/googleapis/googleapis/blob/master/google/pubsub/v1/pubsub.proto)) is remaining the same.

## High level changes

1. The existing admin API will be deprecated, and replaced with the gRPC autogenerated surface. This includes CRUDL operations for topics, subscriptions, schemas, and IAM. Some of these changes may be surprising, see below for detailed examples.
2. The Topic and Subscription structs will be renamed to Publisher and Subscriber respectively.
3. Removed settings: (ReceiveSettings.Synchronous, PublishSettings.BufferedByteLimit, ReceiveSettings.UseLegacyFlowControl)
4. Settings rename (e.g. MaxExtensionPeriod -> MaxDurationPerAckExtension)
5. Changes in defaults (ReceiveSettings.NumGoroutines will now default to 1)
6. Error types related to Publisher/Subscribers are being renamed: ErrTopicStopped -> ErrPublisherStopped

## Admin operations

The Pub/Sub admin plane, also known as the control plane, handles the lifecycle of server-side resources like topics, subscriptions, and schemas. This API consists of admin operations such as Create, Get, Update, List, and Delete.

One of the key differences between the v1 and v2 is the change to the existing admin API. The new way to make admin calls like `CreateTopic` will be through the lower-level gRPC client. These are exposed by two clients: `TopicAdminClient` and `SubscriptionAdminClient`.

There are two ways to instantiate these admin clients:

1. You can import the `cloud.google.com/go/v2/apiv1` package and instantiate a client by calling `NewTopicAdminClient` or `NewSubscriptionAdminClient`  
2. You can access these admin clients directly from the pubsub `Client` exposed in `cloud.google.com/go/pubsub/v2` by calling `Client.TopicAdminClient` (recommended)

In most scenarios, it is preferred and easier to access the client via the second method. The former is preferred if you only need to manage schemas, or you need to manage either Topics or Subscriptions (but not both) AND are also not using any data plane calls (`Publish` and `Receive`).

There is a mostly one-to-one mapping of existing admin methods to the new admin methods.

One notable exception to the above is that the autogenerated admin library does not provide an `Exists` method. This can be done by performing a `GetTopic` operation and checking for an error, but we recommend following the pattern of [optimistically expecting a resource exists](https://cloud.google.com/pubsub/docs/samples/pubsub-optimistic-subscribe#pubsub_optimistic_subscribe-go) and then handling the not found error, which saves a network call.

The new gRPC-based admin client uses a standard gRPC request/response format. If you have used other Google Cloud go libraries like the Compute Engine API or Secret Manager API, this should be familiar.

Here is an example of the differences between creating a Topic via the current API, and how this will be done in the v2.

```go
// v1 library way to create a topic

projectID := "my-project"
topicID := "my-topic"
client, err := pubsub.NewClient(ctx, projectID)

topic, err := client.CreateTopic(ctx, topicID)
```

```go
// v2 library to create a topic

projectID := "my-project"
topicID := "my-topic"
client, err := pubsub.NewClient(ctx, projectID)

topicpb := &pubsubpb.Topic{
	Name: fmt.Sprintf("projects/%s/topics/%s", projectID, topicID),
}
_, err := client.TopicAdminClient.CreateTopic(ctx, topicpb)
```

In this case, `CreateTopic` will now take in a generated protobuf type, `pubsubpb.Topic` that is based on the Topic defined in [pubsub.proto](https://github.com/googleapis/googleapis/blob/3808680f22d715ef59493e67a6fe82e5ae3e00dd/google/pubsub/v1/pubsub.proto#L678). A key difference here is that the `Name` of the proto type is the fully qualified name for the topic, rather than just the project ID.

Let’s look at the differences for another operation: `DeleteTopic`.

```go
// v1 library way to delete a topic

projectID := "my-project"
topicID := "my-topic"
client, err := pubsub.NewClient(ctx, projectID)

topic := client.Topic(topicID)
topic.Delete(ctx)
```

```go
// v2 library way to delete a topic

projectID := "my-project"
topicID := "my-topic"
client, err := pubsub.NewClient(ctx, projectID)

req := &pubsubpb.DeleteTopicRequest{
	Topic: fmt.Sprintf("projects/%s/topics/%s", projectID, topicID),
}
client.TopicAdminClient.DeleteTopic(ctx, req)
```

Note in this case, you have to instantiate a `DeleteTopicRequest` object and pass that in to the `DeleteTopic` call. This includes specifying the full path of the topic, rather than just the topic ID.

There are a few other differences between the existing admin API and the new admin API.

### Update RPCs

Update RPCs require passing a FieldMask protobuf type along with the resource you are modifying. The service uses the field mask to know which fields should be updated, as zero value fields could otherwise mean both “don’t edit” or “remove this value”. The strings to pass into the update field mask should be the name of the field of the resource you are editing, written in snake\_case (e.g. `message_storage_policy)`. These should match the field names in the [proto definition](https://github.com/googleapis/googleapis/blob/master/google/pubsub/v1/pubsub.proto).

If a field mask is not present on update, the operation applies to all fields (as if a field mask of all fields has been specified) and overrides the entire resource.

```go
// v1 way to update subscriptions
projectID := "my-project"
subID := "my-subscription"
client, err := pubsub.NewClient(ctx, projectID)

cfg := pubsub.SubscriptionConfigToUpdate{EnableExactlyOnceDelivery: true}
subConfig, err := client.Subscription(subID).Update(ctx, cfg)
```

```go
// v2 way to update subscriptions
projectID := "my-project"
subID := "my-subscription"
client, err := pubsub.NewClient(ctx, projectID)
updateReq := &pb.UpdateSubscriptionRequest{
	Subscription: &pb.Subscription{EnableExactlyOnceDelivery: true},
	UpdateMask: &fieldmaskpb.FieldMask{
		Paths: []string{"enable_exactly_once_delivery"},
	},
}
```

### RPCs involving one-of fields

RPCs that include one-of fields require instantiating specific Go generated protobuf structs that satisfy the interface type. This may involve generating structs that look duplicated. An example of this can be found below.

```go
// v1 way to create topic ingestion from kinesis
cfg := &pubsub.TopicConfig{
	IngestionDataSourceSettings: &pubsub.IngestionDataSourceSettings{
		Source: &pubsub.IngestionDataSourceAWSKinesis{
			StreamARN:         streamARN,
			ConsumerARN:       consumerARN,
			AWSRoleARN:        awsRoleARN,
			GCPServiceAccount: gcpServiceAccount,
		},
	},
}

t, err := client.CreateTopicWithConfig(ctx, topicID, cfg)
```

```go
// v2 way to create topic ingestion from kinesis
kinesis := &pubsubpb.IngestionDataSourceSettings_AwsKinesis{
	StreamArn:         streamARN,
	ConsumerArn:       consumerARN,
	AwsRoleArn:        awsRoleARN,
GcpServiceAccount: gcpServiceAccount,
},

topicpb := &pubsubpb.Topic{
	IngestionDataSourceSettings: &pubsubpb.IngestionDataSourceSettings{
		Source: &pubsubpb.IngestionDataSourceSettings_AwsKinesis_{
			AwsKinesis: kinesis,
		},
	},
}

t, err := client.TopicAdminClient.CreateTopic(ctx, t)
```

### Other notable differences

The new types and fields of the autogenerated library may be protobuf specific and
may differ from the current v1 fields.

For example, message retention duration was defined as `Topic.RetentionDuration`,
but in the v2 it is now `Topic.MessageRetentionDuration`, which reflects the type
defined by the [proto](https://github.com/googleapis/googleapis/blob/bbeb0530ac9d8a61d8156f0d4e111909fc2827aa/google/pubsub/v1/pubsub.proto#L841).

In another case, generated protobuf code doesn't follow Go styling guides for initialisms.
For example, `Topic.KMSKeyName` is defined as `KmsKeyName` in the v2 library.

In addition, the v1 library uses custom `optional` types for certain fields for durations and bools.
Now some custom fields such as `time.Duration` now use a protobuf specific
[`durationpb.Duration`](https://pkg.go.dev/google.golang.org/protobuf/types/known/durationpb).

On duration, `Subscription.ExpirationPolicy` as defined by the v2 code is now a struct
that wraps a `durationpb` type, which may be surprising.

For more specific documentation, please refer to the method calls and arguments
defined by the [autogenerated library](https://pkg.go.dev/cloud.google.com/go/pubsub/v2/apiv1)
and [Go protobuf types](https://pkg.go.dev/cloud.google.com/go/pubsub/v2/apiv1/pubsubpb).

### Schemas

The existing Schema client will also be removed in favor of the autogenerated schema client. This is similar to the topic and subscription admin clients above, but can only be instantiated by doing calling the `NewSchemaClient` method in [`cloud.google.com/go/pubsub/v2/apiv1`](http://cloud.google.com/go/pubsub/v2/apiv1)

```go
import (
	pubsub "cloud.google.com/go/pubsub/v2/apiv1"
	"cloud.google.com/go/pubsub/v2/apiv1/pubsubpb"
)

func getSchema(projectID, schemaID string) error {
	// projectID := "my-project-id"
	// schemaID := "my-schema"
	ctx := context.Background()
	client, err := pubsub.NewSchemaClient(ctx)
	if err != nil {
		return fmt.Errorf("pubsub.NewSchemaClient: %w", err)
	}
	defer client.Close()

	req := &pubsubpb.GetSchemaRequest{
		Name: fmt.Sprintf("projects/%s/schemas/%s", projectID, schemaID),
		View: pubsubpb.SchemaView_FULL,
	}
	s, err := client.GetSchema(ctx, req)
	if err != nil {
		return fmt.Errorf("client.GetSchema: %w", err)
	}
	return nil
}
```

The main difference with the new autogenerated schema client is that you no longer will pass in a project ID at client instantiation. Instead, all references to schemas will be done by its fully qualified resource name.

## Data Plane Operations

In contrast with admin operations that deal with resource management, the data plane deals with publishing and receiving messages.

In the current v1, the data plane clients are intermixed with the admin plane resources, topics and subscriptions. For example, the `Topic` struct has a `Publish` method. We will be renaming these clients so that instead of constructing a `Topic` for data plane operations, you will instead create a `Publisher` instead.

Similarly, `Subscription` will be renamed to `Subscriber`.

Currently, instantiating topics and subscriptions only take in the resource ID, where the project name is inferred from the project string passed into `pubsub.NewClient`. One common paradigm currently is calling `CreateTopic` and then calling `Publish` from the returned topic. Since the new `CreateTopic` no longer returns a data plane publisher client, but rather just metadata about the topic itself, you will need to instantiate your own Publisher client.

To make this transition easier, we changed the `Publisher` and `Subscriber` methods to be flexible in what kind of argument it accepts, allowing for both resource IDs and fully qualified resource names at instantiation. This makes it easier to use the fully qualified topic name (accessible via `topic.GetName()`) rather than needing to parse out just the topicID.

```go
projectID := "my-project"
topicID := "my-topic"
client, err := pubsub.NewClient(ctx, projectID)

topic := &pubsubpb.Topic{
	Name: fmt.Sprintf("projects/%s/topics/%s", projectID, topicID),
}
topic, err := client.TopicAdminClient.CreateTopic(ctx, topic)

// Note, Publisher can take in either a topicID, "my-topic" OR topic fully
// qualified name, "projects/p/topics/my-topic"
// But it is only possible to retrieve the FQN from the protobuf type
publisher := client.Publisher(topic.GetName())
_ := publisher.Publish(ctx, msg)
```

This also removes the need for the `TopicInProject` and `SubscriptionInProject` methods which existed previously.

### Renamed Settings

Two subscriber flow control settings will be renamed:

- MinExtensionPeriod \-\> MinDurationPerAckExtension  
- MaxExtensionPeriod \-\> MaxDurationPerAckExtension

### Default Settings Changes

To align with other client libraries, we will be changing the default value for `ReceiveSettings.NumGoroutines` to 1\. This is a better default for most users as each stream can handle 10 MB/s and will reduce the number of idle streams for lower throughput applications.

### Removed Settings

We will also mention the removal of previously marked deprecated options:

`PublishSettings.BufferedByteLimit` is now functionally superseded by setting the publisher flow control's `MaxOutstandingBytes`.

`ReceiveSettings.Synchronous` used to make the library use the synchronous `Pull` API for the mechanism to receive messages, but users will just use the default asynchronous `StreamingPull` mechanism instead.

Lastly, we will be removing `ReceiveSettings.UseLegacyFlowControl`, which previously allowed the library to disable server side flow control.

# FAQ

**Why does the new admin API package mention both v2 and apiv1?**

The package of the new Pub/Sub library is `cloud.google.com/go/v2`. All of the new v2 code will live in the v2 directory. `apiv1` refers to the version of the Pub/Sub server/client API. While the client library is changing, the way it talks to the server is still technically under a v1.

**Why are you changing the admin API surface?**

Some of the goals we have for this new Pub/Sub package is to reduce confusion between the data and admin plane surfaces. Particularly, the way that this package references topics and subscriptions was inconsistent with other Pub/Sub libraries in other languages. Creating a topic does not automatically create a publisher client in the Java or Python client libraries for example. Instead, it should be more clear to users that creating a topic is a server side operation and creating a publisher client is a client side operation.

In the past, we have had users be confused about why setting topic.PublishSettings doesn't persist the settings across applications. This is because we are actually setting the ephemeral PublishSettings of the client, which isn't persisted to the server.

Another goal is to improve development velocity by leveraging our autogeneration tools that already exist for other Go products. With this change, changes that only affect the admin plane (including recent features such as Topic ingestion settings and export subscriptions) can be released sooner.

**What do I have to do to migrate?**

Primarily, migration means the following

1. A find and replace of `Topic()` and `Subscription()` instantiation calls to call `Publisher()` and `Subscriber()` instead.  
2. Any references to the admin operations (CreateTopic, DeleteTopic, etc) will need to be rewritten with the v2 admin API  
3. Existing code that creates a resource and using that to make data plane calls will need to be changed. For example, if you currently call `CreateTopic` and use the returned `Topic` to make the `Publish` RPC, you will need to instantiate the `Publisher` client, and then using that to call `Publish`.  
4. A find and replace of settings name changes mentioned above  
5. Removing references to deprecating settings (Synchronous, BufferedByteLimit, UseLegacyFlowControl)

---
